<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Test of WebSockets</title>
<style type="text/css">

html {
	font-family: arial ;
}

#messageCount {
	font-size: 8pt ;
	position:absolute;
	right: 0 ;
	top: 0 ;
}
.grid {
	border-collapse: collapse ;
}
.menuButton {
	margin-left: 0.01cm ;
	font-size: 9pt ;
}

.expand-button {
	width:9pt;
	height:9pt;
	margin:0px;
	padding:0px;
	font-size:6pt;
	font-weight:bold;
}
.hdrCell {
	font-size: 8pt ;
	color: navy ;
	width: 1.3cm ;
	text-align: right;
	font-weight: bold ;
} 
.labelHdrCell {
	font-size: 8pt ;
	color: navy ;
	width: 1.3cm ;
	text-align: left;
	font-weight: bold ;
} 
.dataCell {
	font-size: 8pt ;
	text-align: right;
	padding-left: 0.02cm;
} 
.hdrRow2 {
	background: lightSteelBlue ;
	line-height: 11pt ;
} 
.hdrRow1 {
	background: skyBlue ;
	line-height: 11pt ;
} 
.hdrRow0 {
	background: powderblue ;
	line-height: 11pt ;
} 
.totalRow2 {
	background: lightSteelBlue ;
	font-weight: bold ;
	border-bottom: solid 1px navy ;
	line-height: 9pt ;
} 
.totalRow1 {
	background: skyblue ;
	font-weight: bold ;
	border-bottom: solid 1px cyan ;
	line-height: 9pt ;
} 
.totalRow0 {
	background: powderblue ;
	font-weight: bold ;
	border-bottom: solid 1px antiquewhite ;
	line-height: 9pt ;
} 
.dataRow:nth-child(odd) {
	background: lavender ;
	line-height: 9pt ;
} 

.dataRow:hover, tr:hover {
	  background: yellow;
}

</style>

<script>

	
    var socket;
    var timerFunction ;
    var host = "ws://" + document.location.host + "/live" ;
    var colLevels ; 
    var rowLevels ;
    var openViewName ;
    var numMessages = 0 ;
 	var messageCountAtPreviousHeartbeat = 0 ;	
    
    openWebSocket() ;
    
    function openWebSocket() {
    	if( socket != null ) {
    		socket.close() ;
    	}
        socket = new WebSocket( host );
        socket.onopen = socketOpen ;  
        socket.onmessage = socketMessage ;
        socket.onclose = socketClose ;  
    }
 
    function heartbeatTimeout() {
    	if( numMessages === messageCountAtPreviousHeartbeat ) {
    		statusBad( "Server connection lost" ) ;
    		//openWebSocket() ;
    	}
		messageCountAtPreviousHeartbeat = numMessages ;    
	}
    
    function socketOpen() {  
        timerFunction = setInterval(function(){heartbeatTimeout()},3000);
    	statusOK( "Server connection active" ) ;
    	sendObj( { command:"VIEWS" } ) ;
    }  

    function socketClose() {
    	socket = null ;
    	clearTimeout( timerFunction ) ;
    	statusBad( "Server connection closed" ) ;
    }      
    
    function socketMessage( msgText ) {
    	numMessages++ ; // used by heartbeat timer.
    	var msgs = JSON.parse( msgText.data ) ;
    	for( var msgIndex = 0 ; msgIndex<msgs.length ; msgIndex++ ) {
    		var msg = msgs[ msgIndex ] ;
    		if( openViewName !== msg.viewName ) {
    			continue ;
    		} 
    		 
		  	if( msg.command === "UPD" ) {
		  		document.getElementById( "messageCount" ).textContent = "Msg Count " + numberWithCommas(numMessages) ;
	        	
	       		var cell = findViewCell( 'grid', msg.colKeys, msg.rowKeys ) ;
	           	if( cell != null ) {
	        		cell.textContent= msg.value ;
	        	}
		  	} else if( msg.command === "DEL" ) {
	        	
	       		var cell = findViewCell( 'grid', msg.colKeys, msg.rowKeys ) ;
	           	if( cell != null ) {
	        		cell.textContent= "" ;
	        	}
	           	removeRowIfEmpty( msg.rowKeys ) ;
	           	removeColIfEmpty( msg.colKeys ) ;
	
		  	} else if( msg.command === "DELC" ) {
	           	removeCol( msg.colKeys ) ;
		  	} else if( msg.command === "DELR" ) {
	           	removeRow( msg.rowKeys ) ;
		  	} else if( msg.command === "VIEWS" ) {
	   			processViewResponse( msg.responses ) ;
		  	} else if( msg.command === "DIM" ) {
		  		numMessages = 1 ; // reset message count for a new View
	       		statusOK( msg.description ) ;
	       		colLevels = msg.colKeys ;
	       		rowLevels = msg.rowKeys ;
	       		numColLevels = msg.colKeys.length ;
	       		numRowLevels = msg.rowKeys.length ;
	       		resetView() ;
		  	} else if( msg.command === "RDY" ) {
		  		document.getElementById('grid').style.display="block";
		  		sendObj( msg ) ;  // echo the ready message to enable updates in server
		  	} else if( msg.command === "CLOSE" ) {
	       		statusOK( "Received CLOSE for currently running view." ) ;
	       		resetView() ;
		  	} else if( msg.command === "RESET" ) {
	       		statusOK( "View definitions were change on the server, updating is temporarily paused." ) ;
		  		openView( openViewName ) ;  		
		  	} else {
		  		statusBad( "Unknown server msg: " + msg.command ) ;
		  	}
		}
  	}
       
/*
	If I asked what the views are - this is the response
	views is an array of view names that can be opened
*/
    function processViewResponse( views ) {
    	var viewMenu = document.getElementById("viewMenu");    	
		var lastOpenView = getKey( "openView" ) ;
    	
    	var menuHtml = "" ;
    	
    	for( var i=0 ; i<views.length ; i++ ) {
    		menuHtml += "<input type='button' class='menuButton' onclick=\"openView('" + views[i] +"')\" value=\"" + views[i] + "\"/>" ;
    		if( views[i] == lastOpenView ) {
    			openView( lastOpenView  ) ;
    		}
    	}
    	    	
    	viewMenu.innerHTML = menuHtml ;
    }

/*
	Hide the view - so that we can receive all the updates
	and eventually redraw the  web-page. This is actually faster
	than processing a lot of updates. If the view is small 
	then the previous statement is inaccurate.
	
	rowLevels & colLevels must be initialized (i.e. in response to a DIM msg 
	or a col/row expand/collapse)	
*/    
	function resetView() {
		var grid = document.getElementById('grid');
		grid.style.display="none";

		var gridHTML = "" ;
		for( var i=0 ; i<numColLevels ; i++ ) {
			gridHTML += "<tr class='hdrRow" + (i%3) + "'>" ;
			for( var j=0 ; j<numRowLevels ; j++ ) {				
				if( i== (numColLevels-1) ) { 
					gridHTML += "<th class='labelHdrCell'>" + rowLevels[j] +"</th>" ;
				} else {
					gridHTML += "<th class='labelHdrCell'>&nbsp;</th>" ;
				}
			}
			gridHTML += "</tr>" ;		
		}
		
		grid.innerHTML = gridHTML ;		
	}

//=======================
// Global functions
//
	function makeCompoundKeyFromText( keys1, keys2 ) {
		return keys1 + "@" + keys2  ;
	}
	function makeKey( keys ) {
		return keys.join('\t' ) ;
	}
	function makeKeys( key ) {
		return key.split('\t' ) ;
	}
	function makeCompoundKey( keys1, keys2 ) {
		return makeCompoundKeyFromText( makeKey( keys1 ), makeKey( keys2 ) ) ;
	}
	function printKeys( keys ) {
		return "[" + keys.map( function(e) { return "'" + e + "'" ; } ).join(',')  + "]";
	}
	function printKey( key ) {
		return printKeys( makeKeys( key ) ) ;
	}
	
	function views() {
		sendObj( {"command":"VIEWS"} ) ;
 	}

	function sendObj( obj ) {
		socket.send( JSON.stringify(obj) ) ;			
	}

	function openView( view ) {
		if( openViewName !== view ) {
			sendObj( { viewName:openViewName, 
						command:"STOP" } ) ;
		}
		
		openViewName = view ;
		setKey( "openView", view ) ;
		document.getElementById('grid').style.display="none";

		statusOK( "Requesting " + view + " from server.") ;
		var msg = { viewName:openViewName, 
					command:"START",
					rowKeys:[],
					colKeys:[] } ;

	//
	// Pull the view open rows and cols from local storage
	//
						
 		if(typeof(Storage)!=="undefined") {
 			var openRowKey = openViewName+"\fEXR\f" ;
 			var openColKey = openViewName+"\fEXC\f" ;
 			for (i=0; i<localStorage.length; i++) {  
 		        key = localStorage.key(i);
 		        if( key.startsWith( openRowKey ) ) {
 	 		 		msg.rowKeys.push( key.substring( openRowKey.length ) ) ; 	 		        
 		        }
 		        if( key.startsWith( openColKey )  ) {
 	 		 		msg.colKeys.push( key.substring( openColKey.length ) ) ; 	 		        
 		        }
 		    }
 		} 	
		sendObj( msg ) ;
 	}
	
	function closeAll() {
		openViewName = null ;
		sendObj( { command: "STOP" } ) ;
		socket.close() ;
 	}
 	  
	function removeRowIfEmpty( rowKey ) {
		var row = document.getElementById(rowKey);
		if( row == null ) {
			return ;
		}		
		for( var i=numRowLevels ; i<row.cells.length ; i++ ) {
			if( row.cells[i].textContent.length > 0 ) {
				return ;
			}
		}
		
		row.parentNode.removeChild( row ) ;
	}

	function removeRow( rowKey ) {
		var row = document.getElementById(rowKey);
		if( row != null ) {
			row.parentNode.removeChild( row ) ;
		}
	}

	
	function removeColIfEmpty( colKeys ) {
		var rows = grid.rows ;
		var headerRow = rows[0]
		var numColumns = headerRow.cells.length  ;
		var colIndexToDelete = -1 ; // append new col
		
		var colKey = makeKey( colKeys ) ;
		for( colIndexToDelete=numRowLevels ; colIndexToDelete<numColumns ; colIndexToDelete++ ) {
			var label = headerRow.cells[colIndexToDelete] ;
			if( label.getAttribute("id") == colKey ) {
				break ;
			}
			if( label.getAttribute("id") > colKey ) {
				return ;
			}
		}				

		for( var rowIndex = numColLevels ; rowIndex<rows.length  ; rowIndex++ ) {
			var row = rows[rowIndex] ;
			if( row.cells[colIndexToDelete].textContent.length > 0 ) {
				return ;
			}
		} 
		for( var rowIndex = 0 ; rowIndex<rows.length  ; rowIndex++ ) {
			var row = rows[rowIndex] ;
			row.deleteCell(colIndexToDelete) ;
		} 
	}

	
	function removeCol( colKeys ) {
		var rows = grid.rows ;
		var headerRow = rows[0]
		var numColumns = headerRow.cells.length  ;
		var colKey = makeKey( colKeys ) ;
		var colIndexToDelete = -1 ; // append new col
		for( var i=numRowLevels ; i<numColumns ; i++ ) {
			var label = headerRow.cells[i] ;
			if( label.getAttribute("id") === colKey ) {
				colIndexToDelete = i ;
				break ;
			}
		}				
		if( colIndexToDelete > 0 ) {
			for( var rowIndex = 0 ; rowIndex<rows.length  ; rowIndex++ ) {
				var row = rows[rowIndex] ;
				row.deleteCell(colIndexToDelete) ;
			}
		}
	}


	
 	function findViewRow( name, rowKeys ) {
 	
 		var rowKey = makeKey( rowKeys ) ;
		var row = document.getElementById(rowKey);
		if( row != null ) {
			return row ;
		}

		var grid = document.getElementById(name);
		var rows = grid.rows ;
		var sectionSize = rows.length - numColLevels ;
		var insertionPoint = 0 ;
		var sectionStart = 0 ;
		while( sectionSize>0 ) {
			sectionSize = Math.floor( sectionSize / 2 ) ;
			insertionPoint = sectionStart + sectionSize + +numColLevels ;
			
			var row = rows[insertionPoint] ;
			
			var rowLabel = row.getAttribute( "id" ) ;
			if( rowLabel < rowKey ) {
				sectionStart += sectionSize ;
			}
		}
		//insertionPoint -= sectionSize ;
		for( insertionPoint=sectionStart+numColLevels ; insertionPoint<rows.length ; insertionPoint++ ) {
			var row = rows[insertionPoint] ;
			
			var rowLabel = row.getAttribute( "id" ) ;
			if( rowLabel > rowKey ) {
				break ;
			}
		}			
		// Insert a row in the table at row index 0
  		var newRow   = grid.insertRow(insertionPoint);
  		newRow.setAttribute("id", rowKey );
		newRow.setAttribute("class", "dataRow");

		var numButtonsAddedInThisRow = 0 ;
 		// Insert enough new columns for each level in a row
		for( var i=0 ; i<numRowLevels ; i++ ) {
			var newCell  = newRow.insertCell(i);
			newCell.setAttribute("class", "labelHdrCell");
			if( i<rowKeys.length ) {
				newCell.textContent = rowKeys[i] ;
			} else {
				newRow.setAttribute("class", ("totalRow" + (numButtonsAddedInThisRow % 3) ) );
				if( numButtonsAddedInThisRow == 0 ) {
			        var key = openViewName+"\fEXR\f"+rowKey ;
			 		var state = getKey( key ) ;
					newCell.innerHTML = "<input type='button' class='expand-button' onclick=\"toggleRow( '" + openViewName + "', " + printKeys(rowKeys) + ", this);\" value='" + (state=='OPE' ? '-' : '+') + "' />";
				}
				numButtonsAddedInThisRow++ ;
			}
		}

		for( var j=newRow.cells.length ; j<rows[0].cells.length ; j++ ) {
			newCell  = newRow.insertCell(j);
			newCell.setAttribute("class", "dataCell");
			var colKey = rows[0].cells[j].getAttribute( "id" ) ;
			newCell.setAttribute("id", makeCompoundKeyFromText( colKey, rowKey ) ) ; 
		}

		return newRow ;
	}

 	
 	function findViewCell( name, colKeys, rowKeys ) {

		var colKey = makeKey( colKeys ) ;
		var rowKey = makeKey( rowKeys ) ;
 	
 		var fullKey = makeCompoundKeyFromText( colKey, rowKey ) ;
		var cell = document.getElementById(fullKey);
		if( cell !== null ) {
			return cell ;
		}
	
		var row = findViewRow( name, rowKeys ) ;
		if( row === null ) {
			return null ;
		}
			
		var grid = document.getElementById(name);
		var rows = grid.rows ;
		var headerRow = rows[0]
		var numColumns = headerRow.cells.length  ;
		var insertionPoint ; // which column index will we insert at ?
		for( insertionPoint=numRowLevels ; insertionPoint<numColumns ; insertionPoint++ ) {
			var label = headerRow.cells[insertionPoint] ;
			if( label.getAttribute("id") === colKey ) {
				return document.getElementById(fullKey); // findRow may have created the cell we need...
			}
			if( label.getAttribute("id") > colKey ) {
				break ;
			}
		}	
		// OK we'll insert a new column here ...

		numColumns++ ;
		for( var i=0 ; i<numColLevels ; i++ ) {
			var newCell = rows[i].insertCell(insertionPoint);
			newCell.setAttribute("class", "hdrCell");
			if( i<colKeys.length ) {
				if( i==0 ) {	// only set the ID of the first header row 
					newCell.setAttribute("id", colKey );
				}
				newCell.textContent = colKeys[i] ;
			} else {
		        var key = openViewName+"\fEXC\f"+colKey ;
		 		var state = getKey( key ) ;
				newCell.innerHTML = "<input type='button' class='expand-button' onclick=\"toggleCol( '" + openViewName + "'," + printKeys(colKeys) + ",this);\" value='" + (state=='OPE' ? '-' : '+') + "' />";
			}
		}

		// Oh oh - brand new column - need to update every data row in the table !
		for( var i=numColLevels ; i<rows.length ; i++ ) {
			var row = rows[i] ;
			
			// Add new cells if required to make sure all rows have the proper amount of cells
			newCell = row.insertCell(insertionPoint);
			newCell.setAttribute("id", makeCompoundKeyFromText( colKey, row.getAttribute("id") ) ); 
			newCell.setAttribute("class", "dataCell"); 
		}
			
		return  document.getElementById(fullKey);
 	}

	function numberWithCommas(x) {
    	return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	}
	
 	function getKey( key ) {
 		if(typeof(Storage)!=="undefined") {
 			return localStorage.getItem( key ) ;
 		}
 		return null ;
 	}
 	
 	function setKey( key, val ) {
 		if(typeof(Storage)!=="undefined") {
 			if( val == null ) {
 				localStorage.removeItem( key ) ;
 			} else {
 				localStorage.setItem( key, val ) ;
 			}
 		}
    }

 	function statusOK( msg ) {
 		var status = document.getElementById("status");    	
 		status.innerHTML="<span style='color:green;font-weight:bold;'>" + msg + "</span>" ;
 	}
 	
 	function statusBad( msg ) {
 		var status = document.getElementById("status");    	
 		status.innerHTML="<span style='color:red;font-weight:bold;'>" + msg + "</span>" ;
 	}

 	
 	function toggleRow( view, rowKeys, button ) {

        var key = view+"\fEXR\f"+makeKey(rowKeys) ;
 		var state = getKey( key ) ;
 		
 		if( state == "OPE" ) {
 			setKey(key, null ) ;
 	 		button.value='+' ;
 			sendObj( { "viewName": view, "command": "COR", "rowKeys": rowKeys } ) ;	 			
 		} else {
 			setKey(key, "OPE" ) ;
 	 		button.value='-' ;
 			sendObj( { "viewName": view, "command": "EXR", "rowKeys": rowKeys } ) ;	 			
 		}
 		resetView() ;
 		sendObj( { "viewName": view, "command": "RST" } ) ;
 	}

 	function toggleCol( view, colKeys, button ) { 		
        var key = view+"\fEXC\f"+makeKey(colKeys) ;
 		var state = getKey( key ) ;
 		
 		if( state == "OPE" ) {
 			setKey(key, null ) ;
 	 		button.value='+' ;
 			sendObj( { "viewName": view, "command": "COC", "colKeys": colKeys } ) ;	 			
 		} else {
 			setKey(key, "OPE" ) ;
 	 		button.value='-' ;
 			sendObj( { "viewName": view, "command": "EXC", "colKeys": colKeys } ) ;	 			
 		}
 		resetView() ;
 		sendObj( { "viewName": view, "command": "RST" } ) ;
 	}

</script>

</head>

<body>

<div id="status"></div>
<div id="messageCount"></div>

<!--
<div id="controlMenu">
<button onclick="openWebSocket()">Connect</button>
<button onclick="closeAll()">Disconnect</button>
</div>
-->

<div id="viewMenu"></div>
</div>


<table id="grid" class='grid'></table>

</body>
</html>